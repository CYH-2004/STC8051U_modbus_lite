C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE modbus
OBJECT MODULE PLACED IN .\Objects\modbus.obj
COMPILER INVOKED BY: D:\Software_D\Keil_v5\C251\BIN\C251.EXE Modbus_lite\modbus.c XSMALL INTR2 BROWSE INCDIR(.\User;.\Mo
                    -dbus_lite;.\Library;.\Basic;.\SSD1306) DEBUG PRINT(.\Listings\modbus.lst) TABS(2) OBJECT(.\Objects\modbus.obj) 

stmt  level    source

    1          #include "modbus.h"
    2          
    3          #include "Timer.h"
    4          #include "Uart4.h"      //modbus RTUÊ¹ÓÃUART4
    5          
    6          #include "Uart1.h"      //µ÷ÊÔ´®¿Ú
    7          #include "Uart2.h"      //µ÷ÊÔ´®¿Ú
    8          
    9          uint8_t node_address;
   10          uint8_t node_mode;
   11          
   12          volatile uint8_t xdata discrete_input_register[(DISCRETES_INPUT_MAX + 7) / 8];
   13          volatile uint8_t xdata coil_register[(COILS_MAX + 7) / 8];
   14          volatile uint16_t xdata input_register[INPUT_REG_MAX];
   15          volatile uint16_t xdata holding_register[HOLDING_REG_MAX];
   16          
   17          volatile uint8_t xdata RTU_TX_buffer[256];   //·¢ËÍ»º³åÇø
   18          
   19          //modbus_RTU ³õÊ¼»¯
   20          uint8_t modbus_RTU_init(uint16_t brt, uint8_t mode, uint8_t addr);
   21          uint8_t modbus_mode(void);
   22          
   23          //¸¨Öú³ÌÐò
   24          uint16_t MODBUS_CRC16(uint8_t xdata *p, uint8_t n);
   25          void set_bit(uint8_t *data1, uint8_t pos1, uint8_t *data2, uint8_t pos2);
   26          uint8_t modbus_response_WR_check(uint8_t xdata *RX_mesg, uint8_t xdata *TX_mesg);
   27          
   28          //modbus_RTU ±¾µØ´æ´¢Æ÷·ÃÎÊ
   29          uint8_t xdata *modbus_get_reg_addr(uint16_t reg_addr);
   30          uint8_t modbus_get_bit_status(uint16_t reg_addr, uint8_t *bit_buf);
   31          uint8_t modbus_write_bit_status(uint16_t reg_addr, uint8_t *bit_buf);
   32          uint16_t modbus_get_reg_value(uint16_t reg_addr, uint8_t *bit_buf);
   33          uint16_t modbus_write_reg_value(uint16_t reg_addr, uint16_t *reg_buf);
   34          
   35          
   36          //modbus_RTU Ö÷»ú³ÌÐò
   37          uint8_t modbus_RTU_read_coils(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint8_t *value, u
             -int32_t timeout);
   38          uint8_t modbus_RTU_read_discrete_input(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint8_t 
             -*value, uint32_t timeout);
   39          uint8_t modbus_RTU_read_holding_regs(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint16_t *
             -RX_value_p, uint32_t timeout);
   40          uint8_t modbus_RTU_write_single_coil(uint8_t slave_addr, uint16_t reg_addr, uint16_t value, uint32_t time
             -out);
   41          uint8_t modbus_RTU_write_single_reg(uint8_t slave_addr, uint16_t reg_addr, uint16_t value, uint32_t timeo
             -ut);
   42          uint8_t modbus_RTU_write_multi_coils(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint8_t *V
             -alue_p, uint32_t timeout);
   43          uint8_t modbus_RTU_write_multi_regs(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint16_t *V
             -alue_p, uint32_t timeout);
   44          
   45          //modbus_RTU ´Ó»ú³ÌÐò
   46          uint8_t modbus_RTU_slave_r1(uint8_t xdata *buffer_p, uint8_t data_len);
   47          uint8_t modbus_RTU_slave_r2(uint8_t xdata *buffer_p, uint8_t data_len);
   48          uint8_t modbus_RTU_slave_r3(uint8_t xdata *buffer_p, uint8_t data_len);
   49          uint8_t modbus_RTU_slave_r4(uint8_t xdata *buffer_p, uint8_t data_len);
   50          uint8_t modbus_RTU_slave_r5(uint8_t xdata *buffer_p, uint8_t data_len);
   51          uint8_t modbus_RTU_slave_r15(uint8_t xdata *buffer_p, uint8_t data_len);
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 2   

   52          uint8_t modbus_RTU_slave_r6(uint8_t xdata *buffer_p, uint8_t data_len);
   53          uint8_t modbus_RTU_slave_r16(uint8_t xdata *buffer_p, uint8_t data_len);
   54          
   55          uint8_t modbus_RTU_slave_process(uint8_t xdata *buffer_p, uint8_t data_len);
   56          void modbus_RTU_slave(void);
   57          
   58          
   59          
   60          // modbus_RTU³õÊ¼»¯
   61          uint8_t modbus_RTU_init(uint16_t brt, uint8_t mode, uint8_t addr)
   62          {
   63   1          uint16_t i;
   64   1          // UART3_config(0);
   65   1          UART4_config(2); 
   66   1          node_address = addr;
   67   1          node_mode = mode;
   68   1      
   69   1          for(i=0; i< (DISCRETES_INPUT_MAX + 7) / 8; i++)
   70   1          {
   71   2              discrete_input_register[i] = 0x00;
   72   2          }
   73   1          for(i=0; i< (COILS_MAX + 7) / 8; i++)
   74   1          {
   75   2              coil_register[i] = 0x00;
   76   2          }
   77   1          for(i=0; i< INPUT_REG_MAX; i++)
   78   1          {
   79   2              input_register[i] = 0x00;
   80   2          }
   81   1          for(i=0; i< HOLDING_REG_MAX; i++)
   82   1          {
   83   2              holding_register[i] = 0x0000;
   84   2          }
   85   1          return 1;
   86   1      }
*** WARNING C47 IN LINE 61 OF Modbus_lite\modbus.c: 'brt': unreferenced parameter
   87          
   88          //»ñÈ¡µ±Ç°Ä£Ê½
   89          uint8_t modbus_mode(void)
   90          {
   91   1          return node_mode;
   92   1      }
   93          
   94          //========================================================================
   95          // º¯Êý: uint16_t MODBUS_CRC16(uint8_t *p, uint8_t n)
   96          // ÃèÊö: ¼ÆËãCRC16º¯Êý.
   97          // ²ÎÊý: *p: Òª¼ÆËãµÄÊý¾ÝÖ¸Õë.
   98          //        n: Òª¼ÆËãµÄ×Ö½ÚÊý.
   99          // ·µ»Ø: CRC16Öµ.
  100          // °æ±¾: V1.0, 2022-3-18 Áº¹¤
  101          //========================================================================
  102          uint16_t MODBUS_CRC16(uint8_t xdata *p, uint8_t n)
  103          {
  104   1        uint8_t i;
  105   1        uint16_t crc16;
  106   1      
  107   1        crc16 = 0xffff; //Ô¤ÖÃ16Î»CRC¼Ä´æÆ÷Îª0xffff£¨¼´È«Îª1£©
  108   1        do
  109   1        {
  110   2          crc16 ^= (uint16_t)*p;  //°Ñ8Î»Êý¾ÝÓë16Î»CRC¼Ä´æÆ÷µÄµÍÎ»ÏàÒì»ò£¬°Ñ½á¹û·ÅÓÚCRC¼Ä´æÆ÷
  111   2          for(i=0; i<8; i++)    //8Î»Êý¾Ý
  112   2          {
  113   3            if(crc16 & 1) crc16 = (crc16 >> 1) ^ 0xA001;  //Èç¹û×îµÍÎ»Îª0£¬°ÑCRC¼Ä´æÆ÷µÄÄÚÈÝÓÒÒÆÒ»Î»(³¯µÍÎ»)£¬ÓÃ0Ìî
             -²¹×î¸ßÎ»£¬
  114   3                                    //ÔÙÒì»ò¶àÏîÊ½0xA001
  115   3            else  crc16 >>= 1;              //Èç¹û×îµÍÎ»Îª0£¬°ÑCRC¼Ä´æÆ÷µÄÄÚÈÝÓÒÒÆÒ»Î»(³¯µÍÎ»)£¬ÓÃ0Ìî²¹×î¸ßÎ»
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 3   

  116   3          }
  117   2          p++;
  118   2        }while(--n != 0);
  119   1        return  (crc16);
  120   1      }
  121          
  122          
  123          //Êý¾Ý´¦Àí¸¨Öúº¯Êý£º½«data1µÄpos1Î»ÐÞ¸ÄÎªdata2µÄpos2Î»
  124          void set_bit(uint8_t *data1, uint8_t pos1, uint8_t *data2, uint8_t pos2)
  125          {
  126   1          uint8_t temp;
  127   1      
  128   1          //²Á³ýÄ¿±êÎ»
  129   1          *data1 = ~(*data1);
  130   1          *data1 |= (0x01 << pos1);
  131   1          *data1 = ~(*data1);
  132   1      
  133   1          temp = (*data2 & (0x01 << pos2));
  134   1          temp = temp >> pos2;
  135   1          *data1 |= temp << pos1;//Ð´ÈëÄ¿±êÎ»
  136   1      }
  137          
  138          
  139          //modbus_RTU Ö÷»úÐ´ÃüÁîµÄÓ¦´ð¼ì²é
  140          uint8_t modbus_response_WR_check(uint8_t xdata *RX_mesg, uint8_t xdata *TX_mesg)
  141          {
  142   1          if(RX_mesg[0] != TX_mesg[0]) return 0;  //check slave address
  143   1          if(RX_mesg[1] != TX_mesg[1]) return 0;  //check function code
  144   1          if(RX_mesg[2] != TX_mesg[2]) return 0;  //check starting address Lo
  145   1          if(RX_mesg[3] != TX_mesg[3]) return 0;  //check starting address Hi
  146   1          if(RX_mesg[4] != TX_mesg[4]) return 0;  
  147   1          if(RX_mesg[5] != TX_mesg[5]) return 0;  
  148   1          return 1;
  149   1      }
  150          
  151          
  152          //»ñÈ¡Ö¸¶¨±¾µØ¼Ä´æÆ÷µØÖ·
  153          uint8_t xdata *modbus_get_reg_addr(uint16_t reg_addr)
  154          {
  155   1          if((reg_addr >= DISCRETES_INPUT_START_ADDRESS) && (reg_addr < DISCRETES_INPUT_START_ADDRESS + DISCRET
             -ES_INPUT_MAX))
  156   1          {
  157   2              return &discrete_input_register[(reg_addr - DISCRETES_INPUT_START_ADDRESS) / 8];
  158   2          }
  159   1          else if((reg_addr >= COILS_START_ADDRESS) && (reg_addr < COILS_START_ADDRESS + COILS_MAX))
  160   1          {
  161   2              return &coil_register[(reg_addr - COILS_START_ADDRESS) / 8];
  162   2          }
  163   1          else if((reg_addr >= INPUT_REG_START_ADDRESS) && (reg_addr < INPUT_REG_START_ADDRESS + INPUT_REG_MAX)
             -)
  164   1          {
  165   2              return &input_register[(reg_addr - INPUT_REG_START_ADDRESS)];
  166   2          }
  167   1          else if((reg_addr >= HOLDING_REG_START_ADDRESS) && (reg_addr < HOLDING_REG_START_ADDRESS + HOLDING_RE
             -G_MAX))
  168   1          {
  169   2              return &holding_register[(reg_addr - HOLDING_REG_START_ADDRESS)];
  170   2          }
  171   1          return NULL;
*** WARNING C151 IN LINE 171 OF Modbus_lite\modbus.c: pointer truncation: 'far' to 'xdata'
  172   1      }
  173          
  174          //»ñÈ¡Ö¸¶¨Î»Öµ
  175          uint8_t modbus_get_bit_status(uint16_t reg_addr, uint8_t *bit_buf)
  176          {
  177   1          //¼ì²âÄ¿±êÊÇ·ñÎªÏßÈ¦¼Ä´æÆ÷
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 4   

  178   1          if((reg_addr >= COILS_START_ADDRESS) && (reg_addr < COILS_START_ADDRESS + COILS_MAX))
  179   1          {
  180   2              //¶ÁÈ¡Ö¸¶¨Î»
  181   2              *bit_buf = coil_register[(reg_addr - COILS_START_ADDRESS) / 8] & (0x01 << ((reg_addr - COILS_STAR
             -T_ADDRESS) % 8));
  182   2              *bit_buf = *bit_buf >> ((reg_addr - COILS_START_ADDRESS) % 8);
  183   2              return 1;
  184   2          }
  185   1      
  186   1          //¼ì²âÄ¿±êÊÇ·ñÎªÀëÉ¢ÊäÈë¼Ä´æÆ÷
  187   1          if((reg_addr >= DISCRETES_INPUT_START_ADDRESS) && (reg_addr < DISCRETES_INPUT_START_ADDRESS + DISCRET
             -ES_INPUT_MAX))
  188   1          {
  189   2              //¶ÁÈ¡Ö¸¶¨Î»
  190   2              *bit_buf = discrete_input_register[(reg_addr - COILS_START_ADDRESS) / 8] & (0x01 << ((reg_addr - 
             -COILS_START_ADDRESS) % 8));
  191   2              *bit_buf = *bit_buf >> ((reg_addr - COILS_START_ADDRESS) % 8);
  192   2              return 1;
  193   2          }
  194   1          return 0;
  195   1      }
  196          
  197          //Ð´ÈëÖ¸¶¨Î»Öµ
  198          uint8_t modbus_write_bit_status(uint16_t reg_addr, uint8_t *bit_buf)
  199          {
  200   1          //¼ì²âÄ¿±êÊÇ·ñÎªÏßÈ¦¼Ä´æÆ÷
  201   1          if((reg_addr >= COILS_START_ADDRESS) && (reg_addr < COILS_START_ADDRESS + COILS_MAX))
  202   1          {
  203   2              //Ð´ÈëÖ¸¶¨Î»
  204   2              set_bit(coil_register[(reg_addr - COILS_START_ADDRESS) / 8], ((reg_addr - COILS_START_ADDRESS) % 
             -8), *bit_buf, 0);
*** WARNING C40 IN LINE 204 OF Modbus_lite\modbus.c: 'unsigned char' converted to 'far' pointer
*** WARNING C188 IN LINE 204 OF Modbus_lite\modbus.c: 'parameter 2': value truncated
*** WARNING C40 IN LINE 204 OF Modbus_lite\modbus.c: 'unsigned char' converted to 'far' pointer
  205   2              return 1;
  206   2          }
  207   1          return 0;
  208   1      }
  209          
  210          //»ñÈ¡Ö¸¶¨¼Ä´æÆ÷Öµ
  211          uint16_t modbus_get_reg_value(uint16_t reg_addr, uint16_t *reg_buf)
  212          {
*** WARNING C57 IN LINE 212 OF Modbus_lite\modbus.c: parameter 2: different from declaration
  213   1          //¼ì²âÄ¿±êÊÇ·ñÎªÊäÈë¼Ä´æÆ÷
  214   1          if((reg_addr >= INPUT_REG_START_ADDRESS) && (reg_addr < INPUT_REG_START_ADDRESS + INPUT_REG_MAX))
  215   1          {
  216   2              *reg_buf = input_register[(reg_addr - INPUT_REG_START_ADDRESS)];
  217   2              return 1;
  218   2          }
  219   1      
  220   1          //¼ì²âÄ¿±êÊÇ·ñÎª±£³Ö¼Ä´æÆ÷
  221   1          if((reg_addr >= HOLDING_REG_START_ADDRESS) && (reg_addr < HOLDING_REG_START_ADDRESS + HOLDING_REG_MAX
             -))
  222   1          {
  223   2              *reg_buf = holding_register[(reg_addr - HOLDING_REG_START_ADDRESS)];
  224   2              return 1;
  225   2          }
  226   1          return 0;
  227   1      }
  228          
  229          //Ð´ÈëÖ¸¶¨¼Ä´æÆ÷Öµ
  230          uint16_t modbus_write_reg_value(uint16_t reg_addr, uint16_t *reg_buf)
  231          {
  232   1          //¼ì²âÄ¿±êÊÇ·ñÎª±£³Ö¼Ä´æÆ÷
  233   1          if((reg_addr >= HOLDING_REG_START_ADDRESS) && (reg_addr < HOLDING_REG_START_ADDRESS + HOLDING_REG_MAX
             -))
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 5   

  234   1          {
  235   2              holding_register[(reg_addr - HOLDING_REG_START_ADDRESS)] = *reg_buf;
  236   2              return 1;
  237   2          }
  238   1          return 0;
  239   1      }
  240          
  241          
  242          //modbus_RTU Ö÷»úÖ¸Áî£¬¶ÁÈ¡ÏßÈ¦(0x01)
  243          uint8_t modbus_RTU_read_coils(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint8_t *value, u
             -int32_t timeout)
  244          {
  245   1          uint8_t i;
  246   1          uint8_t wait_flag;
  247   1          uint8_t response_error_code;
  248   1          uint8_t *RX_buffer_p_temp;
  249   1          uint16_t crc;
  250   1          uint32_t start_time;
  251   1      
  252   1          //¼ì²é¼Ä´æÆ÷ÊýÁ¿
  253   1          if(quantity > 0x07D0) return 0x0F;
  254   1      
  255   1          RTU_TX_buffer[0] = slave_addr;      //´ÓÕ¾µØÖ·
  256   1          RTU_TX_buffer[1] = 0x01;            //¹¦ÄÜÂë
  257   1          RTU_TX_buffer[2] = (uint8_t)(reg_addr >> 8); //´æ´¢Æ÷ÆðÊ¼µØÖ·
  258   1          RTU_TX_buffer[3] = (uint8_t)(reg_addr);
  259   1          RTU_TX_buffer[4] = (uint8_t)(quantity >> 8); //ÏßÈ¦ÊýÁ¿
  260   1          RTU_TX_buffer[5] = (uint8_t)(quantity);
  261   1      
  262   1          crc = MODBUS_CRC16(RTU_TX_buffer, 6);
  263   1          RTU_TX_buffer[6] = (uint8_t)(crc);
  264   1          RTU_TX_buffer[7] = (uint8_t)(crc >> 8);
  265   1      
  266   1          UART4_send(RTU_TX_buffer, 8);//·¢ËÍÇëÇóÖ¡
  267   1      
  268   1          //µÈ´ý´Ó»úÏìÓ¦
  269   1          wait_flag = 1;
  270   1          start_time = get_systick();
  271   1          while(wait_flag)
  272   1          {
  273   2              if((get_systick() - start_time) > timeout)
  274   2              {
  275   3                  response_error_code = 1;
  276   3                  wait_flag = 0;  //ÏìÓ¦³¬Ê±
  277   3              }
  278   2              if(B_RX4_OK == 1)
  279   2              {
  280   3                  //ÑéÖ¤ÏìÓ¦Ö¡
  281   3                  response_error_code = 0;
  282   3                  RX_buffer_p_temp = get_RX4_buffer_address();
  283   3                  if(MODBUS_CRC16(RX_buffer_p_temp, get_RX4_buffer_length())) response_error_code = 0x59;
*** WARNING C151 IN LINE 283 OF Modbus_lite\modbus.c: pointer truncation: 'far' to 'xdata'
  284   3                  if(RX_buffer_p_temp[0] != slave_addr) response_error_code = 0x60;
  285   3                  if(RX_buffer_p_temp[1] != 0x01) response_error_code = 0x61;
  286   3                  if(RX_buffer_p_temp[2] != (quantity + 7) / 8) response_error_code = 0x62;
  287   3      
  288   3                  if(response_error_code == 0)//ÏìÓ¦Ö¡ÑéÖ¤³É¹¦
  289   3                  {
  290   4                      for(i = 0; i < RX_buffer_p_temp[2]; i++)//Ìî³ä¼Ä´æÆ÷Êý¾Ý
  291   4                      {
  292   5                          value[i] = RX_buffer_p_temp[3 + i];     
  293   5                      }
  294   4                      wait_flag = 0;
  295   4                  }
  296   3                  UART4_RX_buffer_reset();//Çå½ÓÊÕ±êÖ¾
  297   3              }
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 6   

  298   2          }
  299   1          return response_error_code;
  300   1      }
  301          
  302          //modbus_RTU Ö÷»úÖ¸Áî£¬¶ÁÈ¡ÀëÉ¢ÊäÈë(0x02)¡£Êµ¼Ê³ý¹¦ÄÜÂëÍâÆäÓàÓë¶ÁÈ¡ÏßÈ¦ÍêÈ«Ò»ÖÂ
  303          uint8_t modbus_RTU_read_discrete_input(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint8_t 
             -*value, uint32_t timeout)
  304          {
  305   1          uint8_t i;
  306   1          uint8_t wait_flag;
  307   1          uint8_t response_error_code;
  308   1          uint8_t *RX_buffer_p_temp;
  309   1          uint16_t crc;
  310   1          uint32_t start_time;
  311   1      
  312   1          //¼ì²é¼Ä´æÆ÷ÊýÁ¿
  313   1          if(quantity > 0x07D0) return 0x0F;
  314   1          RTU_TX_buffer[0] = slave_addr;      //´ÓÕ¾µØÖ·
  315   1          RTU_TX_buffer[1] = 0x02;            //¹¦ÄÜÂë
  316   1          RTU_TX_buffer[2] = (uint8_t)(reg_addr >> 8); //´æ´¢Æ÷ÆðÊ¼µØÖ·
  317   1          RTU_TX_buffer[3] = (uint8_t)(reg_addr);
  318   1          RTU_TX_buffer[4] = (uint8_t)(quantity >> 8); //ÏßÈ¦ÊýÁ¿
  319   1          RTU_TX_buffer[5] = (uint8_t)(quantity);
  320   1      
  321   1          crc = MODBUS_CRC16(RTU_TX_buffer, 6);
  322   1          RTU_TX_buffer[6] = (uint8_t)(crc);
  323   1          RTU_TX_buffer[7] = (uint8_t)(crc >> 8);
  324   1      
  325   1          UART4_send(RTU_TX_buffer, 8);//·¢ËÍÇëÇóÖ¡
  326   1      
  327   1          //µÈ´ý´Ó»úÏìÓ¦
  328   1          wait_flag = 1;
  329   1          start_time = get_systick();
  330   1          while(wait_flag)
  331   1          {
  332   2              if((get_systick() - start_time) > timeout)
  333   2              {
  334   3                  response_error_code = 1;
  335   3                  wait_flag = 0;  //ÏìÓ¦³¬Ê±
  336   3              }
  337   2              if(B_RX4_OK == 1)
  338   2              {
  339   3                  //ÑéÖ¤ÏìÓ¦Ö¡
  340   3                  response_error_code = 0;
  341   3                  RX_buffer_p_temp = get_RX4_buffer_address();
  342   3                  crc = MODBUS_CRC16(RX_buffer_p_temp, get_RX4_buffer_length());
*** WARNING C151 IN LINE 342 OF Modbus_lite\modbus.c: pointer truncation: 'far' to 'xdata'
  343   3                  if(crc) response_error_code = 0x59;
  344   3                  if(RX_buffer_p_temp[0] != slave_addr) response_error_code = 0x60;
  345   3                  if(RX_buffer_p_temp[1] != 0x02) response_error_code = 0x61;
  346   3                  if(RX_buffer_p_temp[2] != (uint8_t)((quantity + 7) / 8)) response_error_code = 0x62;
  347   3      
  348   3                  if(response_error_code == 0)//ÏìÓ¦Ö¡ÑéÖ¤³É¹¦
  349   3                  {
  350   4                      for(i = 0; i < RX_buffer_p_temp[2]; i++)//Ìî³ä¼Ä´æÆ÷Êý¾Ý
  351   4                      {
  352   5                          value[i] = RX_buffer_p_temp[3 + i];     
  353   5                      }
  354   4                      wait_flag = 0;
  355   4                  }
  356   3                  UART4_RX_buffer_reset();//Çå½ÓÊÕ±êÖ¾
  357   3              }
  358   2          }
  359   1          return response_error_code;
  360   1      }
  361          
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 7   

  362          //modbus_RTU Ö÷»úÖ¸Áî£¬¶ÁÈ¡¼Ä´æÆ÷(0x03)
  363          uint8_t modbus_RTU_read_holding_regs(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint16_t *
             -RX_value_p, uint32_t timeout)
  364          {
  365   1          uint8_t i;
  366   1          uint8_t wait_flag;
  367   1          uint8_t response_error_code;
  368   1          uint8_t *RX_buffer_p;
  369   1          uint16_t crc;
  370   1          uint32_t start_time;
  371   1      
  372   1          //¼ì²é¼Ä´æÆ÷ÊýÁ¿
  373   1          if(quantity > 0x007D) return 0x0F;
  374   1          RTU_TX_buffer[0] = slave_addr;      //´ÓÕ¾µØÖ·
  375   1          RTU_TX_buffer[1] = 0x03;            //¹¦ÄÜÂë
  376   1          RTU_TX_buffer[2] = (uint8_t)(reg_addr >> 8); //´æ´¢Æ÷ÆðÊ¼µØÖ·
  377   1          RTU_TX_buffer[3] = (uint8_t)(reg_addr);
  378   1          RTU_TX_buffer[4] = (uint8_t)(quantity >> 8); //¼Ä´æÆ÷ÊýÁ¿
  379   1          RTU_TX_buffer[5] = (uint8_t)(quantity);
  380   1          crc = MODBUS_CRC16(RTU_TX_buffer, 6);
  381   1          RTU_TX_buffer[6] = (uint8_t)(crc);
  382   1          RTU_TX_buffer[7] = (uint8_t)(crc >> 8);
  383   1      
  384   1          UART4_send(RTU_TX_buffer, 8);//·¢ËÍÇëÇóÖ¡
  385   1      
  386   1          //µÈ´ý´Ó»úÏìÓ¦
  387   1          wait_flag = 1;
  388   1          start_time = get_systick();
  389   1          while(wait_flag)
  390   1          {
  391   2              if((get_systick() - start_time) > timeout)
  392   2              {
  393   3                  response_error_code = 1;
  394   3                  wait_flag = 0;  //ÏìÓ¦³¬Ê±
  395   3                  // PrintString2("Response time out!\r\n");
  396   3              }
  397   2              if(B_RX4_OK == 1)
  398   2              {
  399   3                  //ÑéÖ¤ÏìÓ¦Ö¡
  400   3                  response_error_code = 0;
  401   3                  RX_buffer_p = get_RX4_buffer_address();
  402   3                  crc = MODBUS_CRC16(RX_buffer_p, get_RX4_buffer_length());
*** WARNING C151 IN LINE 402 OF Modbus_lite\modbus.c: pointer truncation: 'far' to 'xdata'
  403   3                  if(crc) response_error_code = 0x59;
  404   3                  if(RX_buffer_p[0] != slave_addr) response_error_code = 0x60;
  405   3                  if(RX_buffer_p[1] != 0x03) response_error_code = 0x61;
  406   3                  if(RX_buffer_p[2] != (uint8_t)(quantity * 2)) response_error_code = 0x62;
  407   3      
  408   3                  if(response_error_code == 0)//ÏìÓ¦Ö¡ÑéÖ¤³É¹¦
  409   3                  {
  410   4                      for(i = 0; i < RX_buffer_p[2] / 2; i++)//Ìî³ä¼Ä´æÆ÷Êý¾Ý
  411   4                      {
  412   5                          RX_value_p[i] = (uint16_t)(RX_buffer_p[3 + 2 * i]) << 8;;     
  413   5                          RX_value_p[i] |= (uint16_t)(RX_buffer_p[4 + 2 * i]);
  414   5                      }
  415   4                      wait_flag = 0;
  416   4                  }
  417   3                  UART4_RX_buffer_reset();//Çå½ÓÊÕ±êÖ¾
  418   3              }
  419   2          }
  420   1          return response_error_code;
  421   1      }
  422          
  423          
  424          
  425          //modbus_RTU Ö÷»úÖ¸Áî£¬Ð´Èëµ¥ÏßÈ¦(0x05)
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 8   

  426          uint8_t modbus_RTU_write_single_coil(uint8_t slave_addr, uint16_t reg_addr, uint16_t value, uint32_t time
             -out)
  427          {
  428   1          uint8_t wait_flag;
  429   1          uint8_t response_error_code;
  430   1          uint16_t crc;
  431   1          uint32_t start_time;
  432   1      
  433   1          //Éè¶¨ÏßÈ¦×´Ì¬Âë
  434   1          if(value) value = 0xFF00;
  435   1          else value = 0x00; 
  436   1      
  437   1          RTU_TX_buffer[0] = slave_addr;      //´ÓÕ¾µØÖ·
  438   1          RTU_TX_buffer[1] = 0x05;            //¹¦ÄÜÂë
  439   1          RTU_TX_buffer[2] = (uint8_t)(reg_addr >> 8); //´æ´¢Æ÷ÆðÊ¼µØÖ·
  440   1          RTU_TX_buffer[3] = (uint8_t)(reg_addr);
  441   1          RTU_TX_buffer[4] = (uint8_t)(value >> 8); //ÏßÈ¦×´Ì¬Âë
  442   1          RTU_TX_buffer[5] = (uint8_t)(value);
  443   1          crc = MODBUS_CRC16(RTU_TX_buffer, 6);
  444   1          RTU_TX_buffer[6] = (uint8_t)(crc);
  445   1          RTU_TX_buffer[7] = (uint8_t)(crc >> 8);
  446   1      
  447   1          UART4_send(RTU_TX_buffer, 8);//·¢ËÍÇëÇóÖ¡
  448   1      
  449   1          //µÈ´ý´Ó»úÏìÓ¦
  450   1          wait_flag = 1;
  451   1          start_time = get_systick();
  452   1          while(wait_flag)
  453   1          {
  454   2              if((get_systick() - start_time) > timeout)
  455   2              {
  456   3                  response_error_code = 1;
  457   3                  wait_flag = 0;
  458   3              }
  459   2              if(B_RX4_OK == 1)
  460   2              {
  461   3                  response_error_code = 0;
  462   3                  //ÑéÖ¤ÏìÓ¦Ö¡
  463   3                  if(MODBUS_CRC16(get_RX4_buffer_address(), get_RX4_buffer_length()) == 0)  //CRC16Ð£Ñé£¬´íÎóÖ¡¶
             -ªÆú
  464   3                  {
  465   4                      response_error_code = !modbus_response_WR_check(RTU_TX_buffer, get_RX4_buffer_address());
             -   //ÄÚÈÝ¼ì²é
  466   4                      if(response_error_code == 0)
  467   4                      {
  468   5                          wait_flag = 0;
  469   5                      }
  470   4                  }
  471   3                  else
  472   3                  {
  473   4                      response_error_code = 0xF0;
  474   4                  }
  475   3                  UART4_RX_buffer_reset();//Çå½ÓÊÕ±êÖ¾
  476   3              }
  477   2          }
  478   1          return response_error_code;
  479   1      }
  480          
  481          //modbus_RTU Ö÷»úÖ¸Áî£¬Ð´Èëµ¥¼Ä´æÆ÷(0x06)
  482          uint8_t modbus_RTU_write_single_reg(uint8_t slave_addr, uint16_t reg_addr, uint16_t value, uint32_t timeo
             -ut)
  483          {
  484   1          uint8_t wait_flag;
  485   1          uint8_t response_error_code;
  486   1          uint16_t crc;
  487   1          uint32_t start_time;
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 9   

  488   1      
  489   1          RTU_TX_buffer[0] = slave_addr;      //´ÓÕ¾µØÖ·
  490   1          RTU_TX_buffer[1] = 0x06;            //¹¦ÄÜÂë
  491   1          RTU_TX_buffer[2] = (uint8_t)(reg_addr >> 8); //´æ´¢Æ÷ÆðÊ¼µØÖ·
  492   1          RTU_TX_buffer[3] = (uint8_t)(reg_addr);
  493   1          RTU_TX_buffer[4] = (uint8_t)(value >> 8);    //¼Ä´æÆ÷Öµ
  494   1          RTU_TX_buffer[5] = (uint8_t)(value);
  495   1          crc = MODBUS_CRC16(RTU_TX_buffer, 6);
  496   1          RTU_TX_buffer[6] = (uint8_t)(crc);
  497   1          RTU_TX_buffer[7] = (uint8_t)(crc >> 8);
  498   1      
  499   1          UART4_send(RTU_TX_buffer, 8);//·¢ËÍÇëÇóÖ¡
  500   1      
  501   1          //µÈ´ý´Ó»úÏìÓ¦
  502   1          if(RTU_TX_buffer[0] != 0)
  503   1          {
  504   2              wait_flag = 1;
  505   2              start_time = get_systick();
  506   2              while(wait_flag)
  507   2              {
  508   3                  if((get_systick() - start_time) > timeout)
  509   3                  {
  510   4                      response_error_code = 1;
  511   4                      wait_flag = 0;
  512   4                  }
  513   3                  if(B_RX4_OK == 1)
  514   3                  {
  515   4                      response_error_code = 0;
  516   4                      //ÑéÖ¤ÏìÓ¦Ö¡
  517   4                      if(MODBUS_CRC16(get_RX4_buffer_address(), get_RX4_buffer_length()) == 0)  //CRC16Ð£Ñé£¬´íÎ
             -óÖ¡¶ªÆú
  518   4                      {
  519   5                          response_error_code = !modbus_response_WR_check(RTU_TX_buffer, get_RX4_buffer_address
             -());   //ÄÚÈÝ¼ì²é
  520   5                          if(response_error_code == 0)
  521   5                          {
  522   6                              wait_flag = 0;
  523   6                          }
  524   5                      }
  525   4                      else
  526   4                      {
  527   5                          response_error_code = 0xF0;
  528   5                      }
  529   4                      UART4_RX_buffer_reset();//Çå½ÓÊÕ±êÖ¾
  530   4                  }
  531   3              }
  532   2          }
  533   1          else response_error_code = 0;
  534   1          
  535   1          return response_error_code;
  536   1      }
  537          
  538          //modbus_RTU Ö÷»úÖ¸Áî£¬Ð´Èë¶à¸öÏßÈ¦(0x0F)
  539          uint8_t modbus_RTU_write_multi_coils(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint8_t *V
             -alue_p, uint32_t timeout)
  540          {
  541   1          uint8_t i;
  542   1          uint8_t wait_flag;
  543   1          uint8_t response_error_code;
  544   1          uint16_t crc;
  545   1          uint32_t start_time;
  546   1      
  547   1          //¼ì²éÏßÈ¦ÊýÁ¿
  548   1          if(quantity > 0x07B0) return 0x0F;
  549   1          RTU_TX_buffer[0] = slave_addr;      //´ÓÕ¾µØÖ·
  550   1          RTU_TX_buffer[1] = 0x0F;            //¹¦ÄÜÂë
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 10  

  551   1          RTU_TX_buffer[2] = (uint8_t)(reg_addr >> 8); //´æ´¢Æ÷ÆðÊ¼µØÖ·
  552   1          RTU_TX_buffer[3] = (uint8_t)(reg_addr);
  553   1          RTU_TX_buffer[4] = (uint8_t)(quantity >> 8); //ÏßÈ¦ÊýÁ¿
  554   1          RTU_TX_buffer[5] = (uint8_t)(quantity);
  555   1          RTU_TX_buffer[6] = (uint8_t)(quantity / 8 + (quantity % 8 ? 1 : 0)); //×Ö½ÚÊý
  556   1      
  557   1          //Ìî³äÏßÈ¦Êý¾Ý
  558   1          for(i = 0; i < RTU_TX_buffer[6]; i++)
  559   1          {
  560   2              RTU_TX_buffer[7 + i] = Value_p[i];
  561   2          }
  562   1          //Î²×Ö½Ú¶àÓàÊý¾ÝÖÃ0
  563   1          if(quantity % 8) RTU_TX_buffer[6 + RTU_TX_buffer[6]] &= ~(0xFF << (quantity % 8));
  564   1      
  565   1          crc = MODBUS_CRC16(RTU_TX_buffer, (uint8_t)(7 + RTU_TX_buffer[6]));
  566   1          RTU_TX_buffer[7 + RTU_TX_buffer[6]] = (uint8_t)(crc);
  567   1          RTU_TX_buffer[7 + 1 + RTU_TX_buffer[6]] = (uint8_t)(crc >> 8);
  568   1      
  569   1          UART4_send(RTU_TX_buffer, (uint8_t)(7 + 2 + RTU_TX_buffer[6]));//·¢ËÍÇëÇóÖ¡
  570   1      
  571   1          //µÈ´ý´Ó»úÏìÓ¦
  572   1          if(RTU_TX_buffer[0] != 0)
  573   1          {
  574   2              wait_flag = 1;
  575   2              start_time = get_systick();
  576   2              while(wait_flag)
  577   2              {
  578   3                  if((get_systick() - start_time) > timeout)
  579   3                  {
  580   4                      response_error_code = 1;
  581   4                      wait_flag = 0;
  582   4                  }
  583   3                  if(B_RX4_OK == 1)
  584   3                  {
  585   4                      response_error_code = 0;
  586   4                      //ÑéÖ¤ÏìÓ¦Ö¡
  587   4                      if(MODBUS_CRC16(get_RX4_buffer_address(), get_RX4_buffer_length()) == 0)  //CRC16Ð£Ñé£¬´íÎ
             -óÖ¡¶ªÆú
  588   4                      {
  589   5                          response_error_code = !modbus_response_WR_check(RTU_TX_buffer, get_RX4_buffer_address
             -());   //ÄÚÈÝ¼ì²é
  590   5                          if(response_error_code == 0)
  591   5                          {
  592   6                              wait_flag = 0;
  593   6                          }
  594   5                      }
  595   4                      else
  596   4                      {
  597   5                          response_error_code = 0xF0;
  598   5                      }
  599   4                      UART4_RX_buffer_reset();//Çå½ÓÊÕ±êÖ¾
  600   4                  }
  601   3              }
  602   2          }
  603   1          else response_error_code = 0;
  604   1          return response_error_code;
  605   1      }
  606          
  607          
  608          //modbus_RTU Ö÷»úÖ¸Áî£¬Ð´Èë¶à¸ö¼Ä´æÆ÷(0x10)
  609          uint8_t modbus_RTU_write_multi_regs(uint8_t slave_addr, uint16_t reg_addr, uint16_t quantity, uint16_t *V
             -alue_p, uint32_t timeout)
  610          {
  611   1          uint8_t i;
  612   1          uint8_t wait_flag;
  613   1          uint8_t response_error_code;
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 11  

  614   1          uint16_t crc;
  615   1          uint32_t start_time;
  616   1      
  617   1          //¼ì²é¼Ä´æÆ÷ÊýÁ¿
  618   1          if(quantity > 0x007B) return 0x0F;
  619   1          RTU_TX_buffer[0] = slave_addr;      //´ÓÕ¾µØÖ·
  620   1          RTU_TX_buffer[1] = 0x10;            //¹¦ÄÜÂë
  621   1          RTU_TX_buffer[2] = (uint8_t)(reg_addr >> 8); //´æ´¢Æ÷ÆðÊ¼µØÖ·
  622   1          RTU_TX_buffer[3] = (uint8_t)(reg_addr);
  623   1          RTU_TX_buffer[4] = (uint8_t)(quantity >> 8); //¼Ä´æÆ÷ÊýÁ¿
  624   1          RTU_TX_buffer[5] = (uint8_t)(quantity);
  625   1          RTU_TX_buffer[6] = (uint8_t)(quantity * 2); //×Ö½ÚÊý
  626   1          for(i = 0; i < quantity; i++)  //Ìî³ä¼Ä´æÆ÷Êý¾Ý
  627   1          {
  628   2              RTU_TX_buffer[7 + 2 * i] = (uint8_t)(Value_p[i] >> 8);
  629   2              RTU_TX_buffer[7 + 1 + 2 * i] = (uint8_t)(Value_p[i]);
  630   2          }
  631   1          crc = MODBUS_CRC16(RTU_TX_buffer, (uint8_t)(7 + 2 * quantity));
  632   1          RTU_TX_buffer[7 + 2 * quantity] = (uint8_t)(crc);
  633   1          RTU_TX_buffer[7 + 1 + 2 * quantity] = (uint8_t)(crc >> 8);
  634   1      
  635   1          UART4_send(RTU_TX_buffer, (uint8_t)(7 + 2 + 2 * quantity));//·¢ËÍÇëÇóÖ¡
  636   1      
  637   1          //µÈ´ý´Ó»úÏìÓ¦
  638   1          if(RTU_TX_buffer[0] != 0)
  639   1          {
  640   2              wait_flag = 1;
  641   2              start_time = get_systick();
  642   2              while(wait_flag)
  643   2              {
  644   3                  if((get_systick() - start_time) > timeout)
  645   3                  {
  646   4                      response_error_code = 1;
  647   4                      wait_flag = 0;  //ÏìÓ¦³¬Ê±
  648   4                  }
  649   3                  if(B_RX4_OK == 1)
  650   3                  {
  651   4                      response_error_code = 0;
  652   4                      //ÑéÖ¤ÏìÓ¦Ö¡
  653   4                      if(MODBUS_CRC16(get_RX4_buffer_address(), get_RX4_buffer_length()) == 0)  //CRC16Ð£Ñé£¬´íÎ
             -óÖ¡¶ªÆú
  654   4                      {
  655   5                          response_error_code = !modbus_response_WR_check(RTU_TX_buffer, get_RX4_buffer_address
             -());   //ÄÚÈÝ¼ì²é
  656   5                          if(response_error_code == 0)
  657   5                          {
  658   6                              wait_flag = 0;
  659   6                          }
  660   5                      }
  661   4                      else response_error_code = 0xF0;
  662   4                      UART4_RX_buffer_reset();//Çå½ÓÊÕ±êÖ¾
  663   4                  }
  664   3              }
  665   2          }
  666   1          else response_error_code = 0;
  667   1          return response_error_code;
  668   1      }
  669          
  670          
  671          
  672          
  673          
  674          
  675          
  676          //modbus_RTU ´Ó»úÊý¾Ý´¦Àí
  677          /*
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 12  

  678              [Ö§³ÖµÄÖ¸Áî]
  679          
  680           |¶ÁÏßÈ¦×´Ì¬£¨0x01£©|
  681            ÇëÇó
  682          Êý¾Ý:   Õ¾ºÅ(µØÖ·)  ¹¦ÄÜÂë   ¼Ä´æµØÖ·   ¼Ä´æÆ÷¸öÊý    CRC16
  683          Æ«ÒÆ:      0          1       2 3         4 5       6 7
  684          ×Ö½Ú:   1 byte   1 byte    1byte      2*n byte  2 byte
  685          
  686            ·µ»Ø
  687          Êý¾Ý:Õ¾ºÅ(µØÖ·)  ¹¦ÄÜÂë   ¶Á³ö×Ö½ÚÊý  ¶Á³öÊý¾Ý  CRC16
  688          Æ«ÒÆ:      0       1        2           3~      ×îºó2×Ö½Ú
  689          ×Ö½Ú:   1 byte   1 byte    1byte      2*n byte  2 byte
  690          
  691          
  692           |¶ÁÀëÉ¢ÊäÈë£¨0x02£©|
  693            ÇëÇó
  694          Êý¾Ý:   Õ¾ºÅ(µØÖ·)  ¹¦ÄÜÂë   ¼Ä´æµØÖ·   ¼Ä´æÆ÷¸öÊý    CRC16
  695          Æ«ÒÆ:      0          1       2 3         4 5       6 7
  696          ×Ö½Ú:   1 byte   1 byte    1byte      2*n byte  2 byte
  697          
  698            ·µ»Ø
  699          Êý¾Ý:Õ¾ºÅ(µØÖ·)  ¹¦ÄÜÂë   ¶Á³ö×Ö½ÚÊý  ¶Á³öÊý¾Ý  CRC16
  700          Æ«ÒÆ:      0       1        2           3~      ×îºó2×Ö½Ú
  701          ×Ö½Ú:   1 byte   1 byte    1byte      2*n byte  2 byte
  702          
  703           |¶Á±£³Ö¼Ä´æÆ÷£¨0x03£©|
  704            ÇëÇó
  705          Êý¾Ý:    µØÖ·    ¹¦ÄÜÂë   ¼Ä´æµØÖ· ¼Ä´æÆ÷¸öÊý  Ð´Èë×Ö½ÚÊý   Ð´ÈëÊý¾Ý   CRC16
  706          Æ«ÒÆ:     0        1        2 3      4 5          6          7~        ×îºó2×Ö½Ú
  707          ×Ö½Ú:   1 byte   1 byte    2 byte   2 byte      1byte       2*n byte   2 byte
  708          
  709            ·µ»Ø
  710          Êý¾Ý:Õ¾ºÅ(µØÖ·)  ¹¦ÄÜÂë   Ð´Èë×Ö½ÚÊý  CRC16
  711          Æ«ÒÆ:      0       1        2       ×îºó2×Ö½Ú
  712          ×Ö½Ú:   1 byte   1 byte    1byte    2 byte
  713          
  714          
  715          
  716          
  717          */
  718          
  719          //modbus_RTU ´Ó»ú¶ÁÏßÈ¦Ö¸Áî´¦Àí(0x01)
  720          uint8_t modbus_RTU_slave_r1(uint8_t xdata *buffer_p, uint8_t data_len)
  721          {
  722   1          uint8_t i;
  723   1          uint16_t coil_num; //Ð´ÈëÏßÈ¦¸öÊý
  724   1          uint16_t coil_index;
  725   1        uint16_t reg_addr;  //¼Ä´æÆ÷µØÖ·
  726   1          uint16_t reg_addr_temp;
  727   1          uint16_t crc;
  728   1      
  729   1          if(data_len != 6) return 0x91;  //ÃüÁî³¤¶È´íÎó
  730   1          if((((uint16_t)buffer_p[4] >> 8) + (uint16_t)buffer_p[5]) > HOLDING_REG_MAX) return 0x93; //¶ÁÈ¡ÏßÈ¦¸
             -öÊý´íÎó
  731   1      
  732   1          reg_addr = (uint16_t)(buffer_p[2] << 8) + buffer_p[3] ;
  733   1          coil_num = (uint16_t)(buffer_p[4] << 8) + buffer_p[5];
  734   1          if((reg_addr < COILS_START_ADDRESS) || (reg_addr > COILS_START_ADDRESS + COILS_MAX)) return 0x92;   /
             -/ÏßÈ¦µØÖ·´íÎó
  735   1      
  736   1          //Ö¸ÁîÕýÈ·£¬¿ªÊ¼×¼±¸Ó¦´ð
  737   1          if(buffer_p[0] != 0)  //·Ç¹ã²¥µØÖ·ÔòÓ¦´ð
  738   1          {
  739   2              RTU_TX_buffer[0] = node_address;            //Õ¾ºÅµØÖ·
  740   2              RTU_TX_buffer[1] = 0x01;                //¹¦ÄÜÂë
  741   2              RTU_TX_buffer[2] = (coil_num + 7) / 8;  //·µ»Ø×Ö½ÚÊý£¬ÏòÉÏÈ¡Õû
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 13  

  742   2      
  743   2              reg_addr_temp = (reg_addr - COILS_START_ADDRESS) / 8;
  744   2              coil_index = (reg_addr - COILS_START_ADDRESS) % 8;   //¶¨Î»ÆðÊ¼Î»
  745   2              for(i = 0; i < coil_num; i++)      //¶ÁÈ¡ÏßÈ¦Öµ
  746   2              {
  747   3                  if(i % 8 == 0) RTU_TX_buffer[3 + i / 8] = 0;
  748   3                  set_bit(&RTU_TX_buffer[3 + i / 8], (uint8_t)(i % 8), &coil_register[reg_addr_temp + coil_inde
             -x / 8], (uint8_t)(coil_index % 8));
  749   3                  coil_index++;
  750   3              }
  751   2              crc = MODBUS_CRC16(RTU_TX_buffer, (uint8_t)(3 + RTU_TX_buffer[2]));    
  752   2              RTU_TX_buffer[3 + RTU_TX_buffer[2]] = crc;
  753   2              RTU_TX_buffer[4 + RTU_TX_buffer[2]] = (uint8_t)(crc >> 8);
  754   2      
  755   2              UART4_send(RTU_TX_buffer, (uint8_t)(5 + RTU_TX_buffer[2]));
  756   2          }
  757   1          return 0;
  758   1      }
  759          
  760          //modbus_RTU ´Ó»ú¶ÁÀëÉ¢ÊäÈëÖ¸Áî´¦Àí(0x02)
  761          uint8_t modbus_RTU_slave_r2(uint8_t xdata *buffer_p, uint8_t data_len)
  762          {
  763   1          uint8_t i;
  764   1          uint16_t descrete_num; //Ð´ÈëÏßÈ¦¸öÊý
  765   1        uint16_t reg_addr;  //¼Ä´æÆ÷µØÖ·
  766   1          uint16_t reg_addr_temp;
  767   1          uint16_t descrete_index;
  768   1          uint16_t crc;
  769   1      
  770   1          if(data_len != 6) return 0x91;  //ÃüÁî³¤¶È´íÎó
  771   1          if((((uint16_t)buffer_p[4] >> 8) + (uint16_t)buffer_p[5]) > HOLDING_REG_MAX) return 0x93; //¶ÁÈ¡ÊäÈë¸
             -öÊý´íÎó
  772   1      
  773   1          reg_addr = (uint16_t)(buffer_p[2] << 8) + buffer_p[3] ;
  774   1          descrete_num = (uint16_t)(buffer_p[4] << 8) + buffer_p[5];
  775   1          if((reg_addr < DISCRETES_INPUT_START_ADDRESS) || (reg_addr > DISCRETES_INPUT_START_ADDRESS + DISCRETE
             -S_INPUT_MAX)) return 0x92;   //ÀëÉ¢ÊäÈëµØÖ·´íÎó
  776   1      
  777   1          //Ö¸ÁîÕýÈ·£¬¿ªÊ¼×¼±¸Ó¦´ð
  778   1          if(buffer_p[0] != 0)  //·Ç¹ã²¥µØÖ·ÔòÓ¦´ð
  779   1          {
  780   2              RTU_TX_buffer[0] = node_address;            //Õ¾ºÅµØÖ·
  781   2              RTU_TX_buffer[1] = 0x01;                //¹¦ÄÜÂë
  782   2              RTU_TX_buffer[2] = (descrete_num + 7) / 8;  //·µ»Ø×Ö½ÚÊý£¬ÏòÉÏÈ¡Õû
  783   2      
  784   2              reg_addr_temp = (reg_addr - COILS_START_ADDRESS) / 8;
  785   2              descrete_index = (reg_addr - COILS_START_ADDRESS) % 8;   //¶¨Î»ÆðÊ¼Î»
  786   2              for(i = 0; i < descrete_num; i++)      //¶ÁÈ¡ÀëÉ¢ÊäÈëÖµ
  787   2              {
  788   3                  if(i % 8 == 0) RTU_TX_buffer[3 + i / 8] = 0;
  789   3                  set_bit(&RTU_TX_buffer[3 + i / 8], (uint8_t)(i % 8), &discrete_input_register[reg_addr_temp +
             - descrete_index / 8], (uint8_t)(descrete_index % 8));
  790   3                  descrete_index++;
  791   3              }
  792   2              crc = MODBUS_CRC16(RTU_TX_buffer, (uint8_t)(3 + RTU_TX_buffer[2]));    
  793   2              RTU_TX_buffer[3 + RTU_TX_buffer[2]] = crc;
  794   2              RTU_TX_buffer[4 + RTU_TX_buffer[2]] = (uint8_t)(crc >> 8);
  795   2      
  796   2              UART4_send(RTU_TX_buffer, (uint8_t)(5 + RTU_TX_buffer[2]));
  797   2          }
  798   1          return 0;
  799   1      }
  800          
  801          //modbus_RTU ´Ó»ú¶Á¶à±£³Ö¼Ä´æÆ÷Ö¸Áî´¦Àí(0x03)
  802          uint8_t modbus_RTU_slave_r3(uint8_t xdata *buffer_p, uint8_t data_len)
  803          {
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 14  

  804   1          uint8_t i,j;
  805   1          uint8_t reg_num;  //Ð´Èë¼Ä´æÆ÷¸öÊý
  806   1        uint16_t reg_addr;  //¼Ä´æÆ÷µØÖ·
  807   1          uint16_t reg_addr_temp;
  808   1          uint16_t crc;
  809   1      
  810   1          if(buffer_p[0] != 0)  //·Ç¹ã²¥µØÖ·ÔòÓ¦´ð
  811   1          {
  812   2              if(data_len != 6)   return 0x91;  //ÃüÁî³¤¶È´íÎó
  813   2              if(buffer_p[4] != 0)  return 0x93;    //¶Á³ö¼Ä´æÆ÷¸öÊý´íÎó
  814   2              if((buffer_p[5]==0) || (buffer_p[5] > HOLDING_REG_MAX)) return 0x93;  //¶Á³ö¼Ä´æÆ÷¸öÊý´íÎó
  815   2              reg_addr = ((uint16_t)buffer_p[2] << 8) + buffer_p[3];  //¼Ä´æÆ÷µØÖ·
  816   2              reg_num = buffer_p[5];  //¶Á³ö¼Ä´æÆ÷¸öÊý
  817   2      
  818   2              if((reg_addr + (uint16_t)buffer_p[5]) > (HOLDING_REG_START_ADDRESS + HOLDING_REG_MAX)) return 0x9
             -2;  //¼Ä´æÆ÷µØÖ·´íÎó
  819   2              if(reg_addr < HOLDING_REG_START_ADDRESS) return 0x92; //¼Ä´æÆ÷µØÖ·´íÎó
  820   2      
  821   2              //Ö¸ÁîÕýÈ·£¬¿ªÊ¼×¼±¸Ó¦´ð
  822   2              RTU_TX_buffer[0] = node_address;    //Õ¾ºÅµØÖ·
  823   2              RTU_TX_buffer[1] = 0x03;        //¶Á¹¦ÄÜÂë
  824   2              RTU_TX_buffer[2] = reg_num * 2;     //·µ»Ø×Ö½ÚÊý
  825   2              reg_addr_temp = reg_addr - HOLDING_REG_START_ADDRESS; //¼Ä´æÆ÷Êý¾ÝÏÂ±ê
  826   2              
  827   2              for(i = 0, j = 3; i < reg_num; i++)
  828   2              {
  829   3                  RTU_TX_buffer[j] = (uint8_t)(holding_register[reg_addr_temp] >> 8);
  830   3                  RTU_TX_buffer[j+1] = (uint8_t)holding_register[reg_addr_temp];
  831   3                  reg_addr_temp++;
  832   3                  j += 2;
  833   3              }
  834   2              crc = MODBUS_CRC16(RTU_TX_buffer, (uint8_t)(3 + RTU_TX_buffer[2]));
  835   2              RTU_TX_buffer[3 + RTU_TX_buffer[2]] = crc;
  836   2              RTU_TX_buffer[4 + RTU_TX_buffer[2]] = (uint8_t)(crc >> 8);
  837   2              UART4_send(RTU_TX_buffer, (uint8_t)(5 + RTU_TX_buffer[2]));
  838   2          }
  839   1          return 0;
  840   1      }
  841          
  842          //modbus_RTU ´Ó»ú¶Á¶àÊäÈë¼Ä´æÆ÷Ö¸Áî´¦Àí(0x04)
  843          uint8_t modbus_RTU_slave_r4(uint8_t xdata *buffer_p, uint8_t data_len)
  844          {
  845   1          uint8_t i,j;
  846   1          uint8_t reg_num;  //Ð´Èë¼Ä´æÆ÷¸öÊý
  847   1        uint16_t reg_addr;  //¼Ä´æÆ÷µØÖ·
  848   1          uint16_t reg_addr_temp;
  849   1          uint16_t crc;
  850   1      
  851   1          if(buffer_p[0] != 0)  //·Ç¹ã²¥µØÖ·ÔòÓ¦´ð
  852   1          {
  853   2              if(data_len != 6)   return 0x91;  //ÃüÁî³¤¶È´íÎó
  854   2              if(buffer_p[4] != 0)  return 0x93;    //¶Á³ö¼Ä´æÆ÷¸öÊý´íÎó
  855   2              if((buffer_p[5]==0) || (buffer_p[5] > INPUT_REG_MAX)) return 0x93;  //¶Á³ö¼Ä´æÆ÷¸öÊý´íÎó
  856   2              reg_addr = ((uint16_t)buffer_p[2] << 8) + buffer_p[3];  //¼Ä´æÆ÷µØÖ·
  857   2              reg_num = buffer_p[5];  //¶Á³ö¼Ä´æÆ÷¸öÊý
  858   2      
  859   2              if((reg_addr + (uint16_t)buffer_p[5]) > (INPUT_REG_START_ADDRESS + INPUT_REG_MAX)) return 0x92; /
             -/¼Ä´æÆ÷µØÖ·´íÎó
  860   2              if(reg_addr < INPUT_REG_START_ADDRESS) return 0x92; //¼Ä´æÆ÷µØÖ·´íÎó
  861   2      
  862   2              //Ö¸ÁîÕýÈ·£¬¿ªÊ¼×¼±¸Ó¦´ð
  863   2              if(buffer_p[0] != 0)  //·Ç¹ã²¥µØÖ·ÔòÓ¦´ð
  864   2              {
  865   3                  RTU_TX_buffer[0] = node_address;    //Õ¾ºÅµØÖ·
  866   3                  RTU_TX_buffer[1] = 0x04;        //¶Á¹¦ÄÜÂë
  867   3                  RTU_TX_buffer[2] = reg_num * 2;     //·µ»Ø×Ö½ÚÊý
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 15  

  868   3                  reg_addr_temp = reg_addr - INPUT_REG_START_ADDRESS; //¼Ä´æÆ÷Êý¾ÝÏÂ±ê
  869   3                  
  870   3                  for(i = 0, j = 3; i < reg_num; i++)
  871   3                  {
  872   4                      RTU_TX_buffer[j] = (uint8_t)(holding_register[reg_addr_temp] >> 8);
  873   4                      RTU_TX_buffer[j+1] = (uint8_t)holding_register[reg_addr_temp];
  874   4                      reg_addr_temp++;
  875   4                      j += 2;
  876   4                  }
  877   3                  crc = MODBUS_CRC16(RTU_TX_buffer, (uint8_t)(3 + RTU_TX_buffer[2]));
  878   3                  RTU_TX_buffer[3 + RTU_TX_buffer[2]] = crc;
  879   3                  RTU_TX_buffer[4 + RTU_TX_buffer[2]] = (uint8_t)(crc >> 8);
  880   3                  UART4_send(RTU_TX_buffer, (uint8_t)(5 + RTU_TX_buffer[2]));
  881   3              }
  882   2          }
  883   1          return 0;
  884   1      }
  885          
  886          //modbus_RTU ´Ó»úÐ´µ¥ÏßÈ¦Ö¸Áî´¦Àí(0x05)
  887          uint8_t modbus_RTU_slave_r5(uint8_t xdata *buffer_p, uint8_t data_len)
  888          {
  889   1          uint8_t i,j;
  890   1        uint16_t reg_addr;  //¼Ä´æÆ÷µØÖ·
  891   1          uint16_t reg_addr_temp;
  892   1          uint16_t crc;
  893   1      
  894   1          if(data_len != 6) return 0x91;  //ÃüÁî³¤¶È´íÎó
  895   1          if((buffer_p[4]!=0xff || buffer_p[5]!=0x00) && buffer_p[4]!=0x00) return 0x93;    //Ð´ÈëÊý¾Ý´íÎó
  896   1      
  897   1          reg_addr = ((uint16_t)buffer_p[2] << 8) + buffer_p[3];  //¶ÁÈ¡¼Ä´æÆ÷µØÖ·
  898   1          if(reg_addr >= (COILS_START_ADDRESS + COILS_MAX)) return 0x92;      //ÏßÈ¦µØÖ·´íÎó
  899   1          if(reg_addr < COILS_START_ADDRESS) return 0x92;     //ÏßÈ¦µØÖ·´íÎó
  900   1      
  901   1          //Ö¸ÁîÕýÈ·£¬¿ªÊ¼Ð´Èë¼Ä´æÆ÷
  902   1          reg_addr_temp = reg_addr - COILS_START_ADDRESS;
  903   1          i = reg_addr_temp / 8; //¶¨Î»¼Ä´æÆ÷Ë÷Òý
  904   1          j = reg_addr_temp % 8; //¶¨Î»¼Ä´æÆ÷Î»
  905   1          if(buffer_p[4] == 0xff) coil_register[i] |= 0x01 << j;  //Ð´ÈëÊý¾Ý, ´ó¶ËÄ£Ê½
  906   1          else coil_register[i] &= (~(0x01 << j));
  907   1      
  908   1          //·¢ËÍÓ¦´ð
  909   1          if(buffer_p[0] != 0)  //·Ç¹ã²¥µØÖ·ÔòÓ¦´ð
  910   1          {
  911   2              for(i = 0; i < 6; i++)  RTU_TX_buffer[i] = buffer_p[i]; //Òª·µ»ØµÄÓ¦´ð
  912   2              crc = MODBUS_CRC16(RTU_TX_buffer, 6);
  913   2              RTU_TX_buffer[6] = (uint8_t)crc;
  914   2              RTU_TX_buffer[7] = (uint8_t)(crc >> 8);
  915   2              UART4_send(RTU_TX_buffer, 8);
  916   2          }
  917   1          return 0;
  918   1      }
  919          
  920          //modbus_RTU ´Ó»úÐ´µ¥¼Ä´æÆ÷Ö¸Áî´¦Àí(0x06)
  921          uint8_t modbus_RTU_slave_r6(uint8_t xdata *buffer_p, uint8_t data_len)
  922          {
  923   1          uint8_t i,j;
  924   1          uint8_t reg_num;  //Ð´Èë¼Ä´æÆ÷¸öÊý
  925   1        uint16_t reg_addr;  //¼Ä´æÆ÷µØÖ·
  926   1          uint16_t reg_addr_temp;
  927   1          uint16_t crc;
  928   1      
  929   1          if(data_len != 6) return 0x91;   //ÃüÁî³¤¶È´íÎó
  930   1      
  931   1          reg_addr = ((uint16_t)buffer_p[2] << 8) + buffer_p[3];  //¶ÁÈ¡¼Ä´æÆ÷µØÖ·
  932   1          if((reg_addr) > (HOLDING_REG_START_ADDRESS + HOLDING_REG_MAX)) return 0x93; //¼Ä´æÆ÷µØÖ·´íÎó
  933   1          if(reg_addr < HOLDING_REG_START_ADDRESS) return 0x93; //¼Ä´æÆ÷µØÖ·´íÎó
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 16  

  934   1      
  935   1          //Ö¸ÁîÕýÈ·£¬¿ªÊ¼Ð´Èë¼Ä´æÆ÷
  936   1          reg_addr_temp = reg_addr - HOLDING_REG_START_ADDRESS;
  937   1          holding_register[reg_addr_temp] = ((uint16_t)buffer_p[4] << 8) + (uint16_t)buffer_p[5]; //Ð´ÈëÊý¾Ý, ´
             -ó¶ËÄ£Ê½
  938   1      
  939   1          //·¢ËÍÓ¦´ð
  940   1          if(buffer_p[0] != 0)  //·Ç¹ã²¥µØÖ·ÔòÓ¦´ð
  941   1          {
  942   2              for(i = 0; i < 6; i++)  RTU_TX_buffer[i] = buffer_p[i]; //Òª·µ»ØµÄÓ¦´ð
  943   2              crc = MODBUS_CRC16(RTU_TX_buffer, 6);
  944   2              RTU_TX_buffer[6] = (uint8_t)crc;
  945   2              RTU_TX_buffer[7] = (uint8_t)(crc >> 8);
  946   2              UART4_send(RTU_TX_buffer, 8);
  947   2          }
  948   1          return 0;
  949   1      }
*** WARNING C47 IN LINE 923 OF Modbus_lite\modbus.c: 'j': unreferenced local variable
*** WARNING C47 IN LINE 924 OF Modbus_lite\modbus.c: 'reg_num': unreferenced local variable
  950          
  951          //modbus_RTU ´Ó»úÐ´¶àÏßÈ¦Ö¸Áî´¦Àí(0x0F)
  952          uint8_t modbus_RTU_slave_r15(uint8_t xdata *buffer_p, uint8_t data_len)
  953          {
  954   1          uint8_t i;
  955   1          uint16_t descrete_num; //Ð´ÈëÏßÈ¦¸öÊý
  956   1          uint16_t coil_index;
  957   1        uint16_t reg_addr;  //¼Ä´æÆ÷µØÖ·
  958   1          uint16_t reg_addr_temp;
  959   1          uint16_t crc;
  960   1      
  961   1          if(data_len < 8) return 0x91;   //ÃüÁî³¤¶È´íÎó
  962   1      
  963   1          descrete_num = ((uint16_t)buffer_p[4] << 8) + buffer_p[5];    //ÏßÈ¦Êý
  964   1          if(((descrete_num + 7) / 8) != buffer_p[6]) return 0x93;  //Ð´ÈëÏßÈ¦¸öÊýÓë×Ö½ÚÊý´íÎó
  965   1          if((descrete_num == 0) || (descrete_num > COILS_MAX)) return 0x93;    //Ð´ÈëÏßÈ¦¸öÊý´íÎó
  966   1      
  967   1          reg_addr = ((uint16_t)buffer_p[2] << 8) + buffer_p[3];  //¶ÁÈ¡¼Ä´æÆ÷µØÖ·
  968   1          if(reg_addr >= (COILS_START_ADDRESS + COILS_MAX)) return 0x92;  //ÏßÈ¦µØÖ·´íÎó
  969   1          if(reg_addr < COILS_START_ADDRESS) return 0x92;     //ÏßÈ¦µØÖ·´íÎó
  970   1      
  971   1          //Ö¸ÁîÕýÈ·£¬¿ªÊ¼Ð´Èë¼Ä´æÆ÷
  972   1          reg_addr_temp = ((reg_addr - COILS_START_ADDRESS) / 8);
  973   1          coil_index = (reg_addr - COILS_START_ADDRESS) % 8;   //¶¨Î»ÆðÊ¼Î»
  974   1          for(i = 0; i < descrete_num; i++)    //Ð´ÈëÊý¾Ý
  975   1          {
  976   2              set_bit(&coil_register[reg_addr_temp + coil_index / 8], (uint8_t)(coil_index % 8), &buffer_p[7 + 
             -i / 8], (uint8_t)(i % 8));
  977   2              coil_index ++;
  978   2          }
  979   1      
  980   1          //·¢ËÍÓ¦´ð
  981   1          if(buffer_p[0] != 0)  //·Ç¹ã²¥µØÖ·ÔòÓ¦´ð
  982   1          {
  983   2              for(i = 0; i < 6; i++)  RTU_TX_buffer[i] = buffer_p[i]; //Òª·µ»ØµÄÓ¦´ð
  984   2              crc = MODBUS_CRC16(RTU_TX_buffer, 6);
  985   2              RTU_TX_buffer[6] = (uint8_t)crc;
  986   2              RTU_TX_buffer[7] = (uint8_t)(crc >> 8);
  987   2              UART4_send(RTU_TX_buffer, 8);
  988   2          }
  989   1          return 0;
  990   1      }
  991          
  992          //modbus_RTU ´Ó»úÐ´¶à±£³Ö¼Ä´æÆ÷Ö¸Áî´¦Àí(0x0F)
  993          uint8_t modbus_RTU_slave_r16(uint8_t xdata *buffer_p, uint8_t data_len)
  994          {
  995   1          uint8_t i,j;
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 17  

  996   1          uint8_t reg_num;  //Ð´Èë¼Ä´æÆ÷¸öÊý
  997   1        uint16_t reg_addr;  //¼Ä´æÆ÷µØÖ·
  998   1          uint16_t reg_addr_temp;
  999   1          uint16_t crc;
 1000   1      
 1001   1          if(data_len < 9) return 0x91;   //ÃüÁî³¤¶È´íÎó
 1002   1          if((buffer_p[4] != 0) || ((buffer_p[5] *2) != buffer_p[6])) return 0x92;  //Ð´Èë¼Ä´æÆ÷¸öÊýÓë×Ö½ÚÊý´íÎó
 1003   1          if((buffer_p[5]==0) || (buffer_p[5] > HOLDING_REG_MAX)) return 0x92;      //Ð´Èë¼Ä´æÆ÷¸öÊý´íÎó
 1004   1      
 1005   1          reg_addr = ((uint16_t)buffer_p[2] << 8) + buffer_p[3];  //¶ÁÈ¡¼Ä´æÆ÷µØÖ·
 1006   1          reg_num = buffer_p[5];      //¶ÁÈ¡Ð´Èë¼Ä´æÆ÷¸öÊý
 1007   1          
 1008   1          if((reg_addr + (uint16_t)buffer_p[5]) > (HOLDING_REG_START_ADDRESS + HOLDING_REG_MAX)) return 0x93; /
             -/¼Ä´æÆ÷µØÖ·´íÎó
 1009   1          if(reg_addr < HOLDING_REG_START_ADDRESS) return 0x93; //¼Ä´æÆ÷µØÖ·´íÎó
 1010   1          if((buffer_p[6] + 7) != data_len) return 0x91;          //ÃüÁî³¤¶È´íÎó
 1011   1      
 1012   1          //Ö¸ÁîÕýÈ·£¬¿ªÊ¼Ð´Èë¼Ä´æÆ÷
 1013   1          reg_addr_temp = reg_addr - HOLDING_REG_START_ADDRESS;
 1014   1          for(i = 0, j = 7; i < reg_num; i++)
 1015   1          {
 1016   2              holding_register[reg_addr_temp] = ((uint16_t)buffer_p[j] << 8) + (uint16_t)buffer_p[j+1]; //Ð´ÈëÊ
             -ý¾Ý, ´ó¶ËÄ£Ê½
 1017   2              reg_addr_temp++;
 1018   2              j += 2;
 1019   2          }
 1020   1      
 1021   1          //·¢ËÍÓ¦´ð
 1022   1          if(buffer_p[0] != 0)  //·Ç¹ã²¥µØÖ·ÔòÓ¦´ð
 1023   1          {
 1024   2              for(i = 0; i < 6; i++)  RTU_TX_buffer[i] = buffer_p[i]; //Òª·µ»ØµÄÓ¦´ð
 1025   2              crc = MODBUS_CRC16(RTU_TX_buffer, 6);
 1026   2              RTU_TX_buffer[6] = (uint8_t)crc;
 1027   2              RTU_TX_buffer[7] = (uint8_t)(crc >> 8);
 1028   2              UART4_send(RTU_TX_buffer, 8);
 1029   2          }
 1030   1          return 0;
 1031   1      }
 1032          
 1033          uint8_t modbus_RTU_slave_process(uint8_t xdata *buffer_p, uint8_t data_len)
 1034          {
 1035   1          uint8_t error_code;
 1036   1          error_code = 0xFF;
 1037   1          switch(buffer_p[1])
 1038   1          {
 1039   2              case 0x01:  // [¶ÁÏßÈ¦]
 1040   2                  error_code = modbus_RTU_slave_r1(buffer_p, data_len);
 1041   2                  break;
 1042   2              case 0x02:  // [¶ÁÀëÉ¢ÊäÈë]
 1043   2                  error_code = modbus_RTU_slave_r2(buffer_p, data_len);
 1044   2                  break;
 1045   2              case 0x03:  //  [¶Á¶à±£³Ö¼Ä´æÆ÷]
 1046   2                  error_code = modbus_RTU_slave_r3(buffer_p, data_len);
 1047   2                  break;
 1048   2              case 0x04:  //  [¶Á¶àÊäÈë¼Ä´æÆ÷]
 1049   2                  error_code = modbus_RTU_slave_r4(buffer_p, data_len);
 1050   2                  break;
 1051   2              case 0x05:  //  [Ð´µ¥ÏßÈ¦]
 1052   2                  error_code = modbus_RTU_slave_r5(buffer_p, data_len);
 1053   2                  break;
 1054   2              case 0x06:  //  [Ð´µ¥±£³Ö¼Ä´æÆ÷]
 1055   2                  error_code = modbus_RTU_slave_r6(buffer_p, data_len);
 1056   2                  break;
 1057   2              case 0x0f:  //  [Ð´¶àÏßÈ¦]
 1058   2                  error_code = modbus_RTU_slave_r15(buffer_p, data_len);
 1059   2                  break;
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 18  

 1060   2              case 0x10:  //  [Ð´¶à¼Ä´æÆ÷]
 1061   2                  error_code = modbus_RTU_slave_r16(buffer_p, data_len);
 1062   2                  break;
 1063   2          }
 1064   1          return error_code;
 1065   1      }
 1066          
 1067          //modbus´Ó»ú´¦Àí³ÌÐò
 1068          void modbus_RTU_slave(void)
 1069          {
 1070   1          uint16_t i;
 1071   1          uint8_t error_code;
 1072   1          uint8_t data_len;
 1073   1          uint8_t xdata *buffer_p;
 1074   1      
 1075   1          error_code = 0xff;
 1076   1          // Uart2_PrintRaw_8(error_code);
 1077   1          if(B_RX4_OK == 1)
 1078   1          {
 1079   2              // PrintString2("Receive data! \r\n");
 1080   2              data_len = get_RX4_buffer_length();
 1081   2              buffer_p = get_RX4_buffer_address();
 1082   2              if(MODBUS_CRC16(buffer_p, data_len) == 0) //CRC16Ð£Ñé£¬´íÎóÖ¡¶ªÆú
 1083   2              {
 1084   3                  // PrintString2("CRC correct! \r\n");
 1085   3      
 1086   3                  if(data_len > 2) data_len -= 2; //¼õÈ¥CRC16Ð£Ñé×Ö½Ú
 1087   3                  if((buffer_p[0] == 0x00) || (buffer_p[0] == node_address))  //Õ¾ºÅ±È¶Ô£¨µØÖ·Ïà·û»òÎª¹ã²¥µØÖ·£©
 1088   3                  {
 1089   4                      error_code = modbus_RTU_slave_process(buffer_p, data_len);  //MODBUS-RTUÐ­Òé½âÎö
 1090   4                      if(error_code != 0) //Êý¾Ý´íÎó´¦Àí
 1091   4                      {
 1092   5                          // PrintString2("Error_code: \r\n");
 1093   5                          // Uart2_PrintRaw_8(error_code);
 1094   5                          // PrintString2("\r\n");
 1095   5                      }
 1096   4                  }
 1097   3              }
 1098   2              else 
 1099   2              {
 1100   3                  // PrintString2("CRC error! \r\n");
 1101   3              }
 1102   2              UART4_RX_buffer_reset();//Çå½ÓÊÕ±êÖ¾
 1103   2      
 1104   2              //test
 1105   2              // for(i = 0; i < HOLDING_REG_MAX; i++)
 1106   2              // {
 1107   2              //     PrintRaw_8((uint8_t)(holding_register[i] >> 8));
 1108   2              //     PrintRaw_8((uint8_t)(holding_register[i]));
 1109   2              // }
 1110   2              // PrintString2("\r\n");
 1111   2              // for(i = 0; i < 10; i++)
 1112   2              // {
 1113   2              //     Uart2_PrintRaw_8(RTU_TX_buffer[i]);
 1114   2              // }
 1115   2              // PrintString2("\r\n");
 1116   2          }
 1117   1      }
*** WARNING C47 IN LINE 1070 OF Modbus_lite\modbus.c: 'i': unreferenced local variable
 1118          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5847     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
C251 COMPILER V5.60.0,  modbus                                                             11/01/26  10:39:44  PAGE 19  

  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       482     ------
  xdata-const size     =    ------     ------
  edata size           =         2         94
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  12 WARNING(S),  0 ERROR(S)
